# List
  - 시퀀스 컨테이너 (sequence container)의 일종이므로 순서를 유지
  - 노드 기반 컨테이너
  - 이중 연결 리스트(doubly linked list)
  - vector, deque과는 다르게 멤버함수에 정렬(sort, merge), 이어붙이기(splice) 존재
  - 원소를 탐색 시, 임의접근 반복자(at(), []) 는 불가능  
    양방향 반복자(++, --) 이용해서 탐색
  - push_front(), push_back(), pop_front(), pop_back() 멤버 함수를 이용해서 list 양 끝에서 삽입, 삭제가 가능
  - insert(), erase() 멤버 함수를 통해서 노드 중간에서도 삽입, 삭제가 가능

### 선언
  ```c
  #include <list>
  list<int> lt;           // 비어있는 list 컨테이너 lt 를 생성
  list<int> lt(n);        // default(0)값으로 초기화 된 원소 n개를 가진 list를 생성
  list<int> lt(n, val);   // val으로 초기화 된 원소 n개를 가진 list를 생성
  list<int> lt2(lt1);     // list lt1을 lt2로 복사
  ```

### 기본함수
  - list 컨테이너에는 at, [] 가 없음

```c
  // ============================== 할당, 접근 ==================================
  lt.assign(3, 4);    // 4로 초기화된 3개의 원소를 할당

  lt.front();         // 맨 앞의 원소를 반환(return)
  lt.back();          // 맨 뒤의 원소를 반환(return)

  // ============================== 삽입, 삭제 ==================================
  lt.push_back(k);    // 뒤쪽으로 원소 k 를 삽입
  lt.push_front(k);   // 앞쪽으로 원소 k 를 삽입
  lt.pop_back();      // 맨 마지막 원소를 제거
  lt.pop_front();     // 맨 첫번째 원소를 제거

  // ============================== ETC ==================================
  lt.size();          // 원소의 개수를 반환
  lt.reverse();       // 원소들의 순차열을 반전
  lt2.swap(lt1);      // lt2와 lt1을 swap
```

### 특이한 멤버함수
  ```c
  // ======================== 조건에 맞는 원소 모두 제거 =======================
  lt.remove(k);             // k와 같은 원소를 모두 제거 (매우 편리)
  lt.remove_if(predicate)   // 단항 조건자 predicate에 해당하는 원소를 모두 제거 (매우 편리)
  bool predicate(int num) {
    return num>=100 && num<=200; // "return true" 인 경우에 제거
  }

  // ============================ 잘라붙이기 ==================================
  lt2.splice(iter2, lt1);               // (호출자 lt2의 iter2)가 가리키는 곳에 (lt1의 모든 원소)를 잘라 붙임
  lt2.splice(iter2, lt1, iter1);        // (호출자 lt2의 iter2)가 가리키는 곳에 (lt1의 iter1이 가리키는 원소)를 잘라 붙임
  lt2.splice(iter2, lt1, it_1, it_2)    // (호출자 lt2의 iter2)가 가리키는 곳에 (lt1의 [it_1 , it_2)) 범위의 원소를 잘라 붙임
  // [ start, end ): start <= x < end

  // ======================= 인접 중복 원소 제거 ==============================
  lt.unique();   // 인접한(양옆의) 원소가 같으면 유일하게 만듦(하나만빼고 삭제)

  // ============================ 정렬 ========================================
  lt.sort();
  // 모든 원소를 default(오름차순) 으로 정렬
  // sort의 파라미터로 이항조건자가 올수 있음, 그때는 그 기준으로 정렬
  lt2.merge(lt1)
  // lt1을 lt2내부로 합병 정렬(default 오름차순)
  // merge함수가 제대로 동작하기 위해서는 합칠 두 list인 lt1, lt2가 이미 정렬이 되어있어야함
  // 두번째 파라미터로 이항 조건자가 올 수 있음, 그때는 그 기준으로 정렬
  ```

### iterator
  ```c
  // ========================== 반복자 (Iterator) ================================
  lt.begin()          // 맨 앞의 원소를 가리키는 iterator를 반환
  // ex) list<int>::iterator iter;
  // iter = lt.begin();

  lt.end()            // 맨 마지막의 다음 원소를 가리키는 iterator를 반환
  // ex) list<int>::iterator iter;
  // iter = lt.end();

  // ========================== 역방향 반복자 ================================
  lt.rbegin();
  //뒤에서부터 원소를 순차적으로 접근할때 편리하게 쓰임
  // begin()과 동일하게 사용

  lt.rend();
  // 뒤에서부터 원소를 순차적으로 접근할때 편리하게 쓰임
  // end()와 동일하게 사용


  // ========================== 반복자 사용한 삽입, 삭제 ================================
  lt.insert(iter, k);
  // iter가 가리키는 위치에 원소 k를 삽입
  // 삽입한 원소를 가리키는 iterator를 반환

  lt.erase(iter);
  // iterator가 가리키는 원소를 삭제
  // 반환값은 삭제한 원소의 다음 원소를 가리키는 iterator를 반환
  ```

### Example
  ```c
  // ========================== 선언, 삽입, 삭제 ==============================
  list<int> lt;

  lt.push_back(10); lt.push_back(10);
  lt.push_back(20); lt.push_back(10);

  // ============================ 정방향 반복 ================================
  list<int>::iterator iter;

  for(iter = lt.begin(); iter!= lt.end(); iter++){
     cout <<*iter << " ";
  }

  // ======================== 지정원소 모두 삭제 ==============================
  //원소가 10 인 원소 제거
  lt.remove(10);

  // ============================ 인접 중복 삭제 ===============================
  //unique멤버 함수를 통해서 붙어있는 인자 삭제
  lt.unique(); // 1,1,2,2,1 -> 1,2,1

  // ============================== 정렬 =======================================
  // sort (default: 오름차순)  //string은 사전순으로 정렬
  lt.sort();
  //sort 내림차순
  lt.sort(greater<string>());

  ```
